from map import Map
from Piece import Piece
import itertools
from matplotlib.animation import FuncAnimation
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import copy
import csv
import time

class Graph:
    def __init__(self, pieces: list = None, map: Map = None, try_point: tuple = (0,0)):
        self.fig, self.ax = plt.subplots()
        self.ax.set_xticks([0,5,10,15])
        self.ax.set_yticks([0,5,10,15])
        self.map = map
        self.border = None
        self.total_pices_placed = None
        if self.map: 
            self.border = self.map.border
            self.total_pieces_placed = 2 + len(self.map.invisible_lines)
        self.pieces = pieces
        self.animation = None
        self.current_piece_index = 0
        self.try_point = try_point
        #self.displace_pieces(piece_displacement)
    """
    SETS PIECES OUTSIDE OF MAP
    """

    def map_creator(self, directions: list[str], line_lengths: list[str]):
        if not line_lengths and not directions:
            return
        if len(line_lengths) != len(directions):
            IndexExror: print("amount of lines and their dircetions do not match")
            return
        def create_coordinates(directions, line_lengths):
            num_lines = len(line_lengths)
            x_coordinates = [0]
            y_coordinates = [0]
            for i in range(num_lines):
                if directions[i] == "n":
                    x_coordinates.append(x_coordinates[-1] + 0)
                    y_coordinates.append(y_coordinates[-1] + line_lengths[i])
                elif directions[i] == "e":
                    x_coordinates.append(x_coordinates[-1] + line_lengths[i])
                    y_coordinates.append(y_coordinates[-1] + 0)                 
                elif directions[i] == "s":
                    x_coordinates.append(x_coordinates[-1] + 0)
                    y_coordinates.append(y_coordinates[-1] - line_lengths[i])
                    if y_coordinates[-1] < 0:
                        y_coordinates = self.shift_graph(y_coordinates, -y_coordinates[-1])
                elif directions[i] == "w":
                    x_coordinates.append(x_coordinates[-1] - line_lengths[i])
                    y_coordinates.append(y_coordinates[-1] + 0)
                    if x_coordinates[-1] < 0:
                        x_coordinates = self.shift_graph(x_coordinates, -x_coordinates[-1])
            #x_coordinates, y_coordinates = shift_graph(x_coordinates, 2), shift_graph(y_coordinates, 2)
            
            return [(x, y) for x, y in zip(x_coordinates, y_coordinates)]
        the_map = Map(create_coordinates(directions, line_lengths))
        if self.map == None: 
            self.map = the_map
        return the_map
    

    def fill_perimater(self):
        """
        for each piece, determine whether it can fit at the try_point 0,0
        if if can, keep going with this piece, updating the try_point and testing pieces until completing the perimater
        create a new Map with the perimater filled (it would be a smaller version of the previous map)
        repeat until all pieces are filled

        
        """
        #at the end of this code I need:
            # new Map ✓
            # reduced set of Pieces ✓ 
            # new try_point with ✓
            # piece adjustment metric with new try point ✓

        #generated by chatgpt
        def on_line(point_a, point_b, check_point):
            # Calculate the cross product and dot product
            cross_product = (check_point[1] - point_a[1]) * (point_b[0] - point_a[0]) - (point_b[1] - point_a[1]) * (check_point[0] - point_a[0])
            dot_product = (check_point[0] - point_a[0]) * (point_b[0] - point_a[0]) + (check_point[1] - point_a[1]) * (point_b[1] - point_a[1])

            # Check if the points are collinear and if check_point is between point_a and point_b
            if abs(cross_product) < 0.001 and dot_product >= 0 and dot_product <= (point_b[0] - point_a[0]) * (point_b[0] - point_a[0]) + (point_b[1] - point_a[1]) * (point_b[1] - point_a[1]):
                return True

            return False

        def find_highest_coord(coordinates):
            if not coordinates: return None
            highest_coord_idx = 0
            for i in range(len(coordinates)):
                if coordinates[i][1] > coordinates[highest_coord_idx][1]:
                    highest_coord_idx = i
            return coordinates[highest_coord_idx]
        #MY VERSION OF ADJUST_PIECES_TO_TRY_POINT
        """
        def adjust_pieces_to_try_point(pieces, distance: list[int]):
            print('before')
            print(pieces[0].orientations[0].coordinates)

            for piece in pieces:
                for orientation in piece.orientations:                 
                    for coordinate in orientation.coordinates:
                        coordinate[0] = coordinate[0] + distance[0]
                        coordinate[1] = coordinate[1] + distance[1]
            print('after')
            print(pieces[0].orientations[0].coordinates)
                
        """
        #CHAT
        def adjust_pieces_to_try_point(pieces, distance):
            print('before')
            print(pieces[0].orientations[0].coordinates)

            for piece in pieces:
                for orientation in piece.orientations:                 
                    orientation.coordinates = [[coord[0] + distance[0], coord[1] + distance[1]] for coord in orientation.coordinates]

            print('after')
            print(pieces[0].orientations[0].coordinates)  
            return pieces  

        #method instuction start
        new_graphs = []
        for index in range(len(self.pieces)):
            for orientation in self.pieces[index].orientations:
                shapely_orientation = Polygon(orientation.coordinates)
                current_orientation = gpd.GeoSeries(shapely_orientation)
                current_orientation.plot(ax=self.ax)

                # UNKOWN WHY THE IF STATEMENT BELOW WORKS
                if current_orientation.touches(self.border, align=True).bool():
                    coordinates_on_perimater = []
                    for i in range(len(self.map.coordinates)-1):
                        for coordinate in orientation.coordinates:
                            if on_line(self.map.coordinates[i], self.map.coordinates[i+1], coordinate):
                                coordinates_on_perimater.append(coordinate)
                    new_try_point = find_highest_coord(coordinates_on_perimater)
                    distance_between_try_points = [new_try_point[0]-self.try_point[0], new_try_point[1]-self.try_point[1]]
                    new_map = self.map.eat_map(shapely_orientation)

                    if isinstance(new_map, MultiPolygon):
                        print("map geoms")
                        print(new_map)
                        print("the geoms")
                        for geom in new_map.geoms:
                            print(tuple(geom.exterior.coords))
                        new_fig, new_ax = plt.subplots()
                        gpd.GeoSeries(shapely_orientation).plot(ax=new_ax, color='purple')
                        for polygon in new_map.geoms:
                            gpd.GeoSeries(polygon).plot(ax=new_ax)
                        self.ax.collections[-1].remove()
                        continue
                        
                    new_map = Map(tuple(new_map.exterior.coords))
                    new_pieces = copy.deepcopy(self.pieces)
                    new_pieces.pop(index)
                    new_pieces = adjust_pieces_to_try_point(new_pieces, distance_between_try_points)
                    new_graph = Graph(new_pieces, new_map, new_try_point)
                    new_graphs.append(new_graph)



                    self.ax.collections[-1].remove()
                else:
                    self.ax.collections[-1].remove()


        return new_graphs
            


    def plot_map(self):
        for line in self.map.invisible_lines:
            gpd.GeoSeries(line).plot(ax=self.ax, color='purple')
        gpd.GeoSeries(self.map.shapely_map).plot(ax = self.ax, color='blue')
        self.border = gpd.GeoSeries(self.map.border)
        self.border.plot(ax = self.ax, color='red')

    
    def display_graph(self, animate: bool = False):
        if animate:
            self.animate()
        plt.show()

    def displace_pieces(self, displacement):
        for piece in self.pieces:
            for orientation in piece:
                for coordinate in orientation.coordinates:
                    coordinate[0] += displacement[0]
                    coordinate[1] += displacement[1]

    def animate(self, interval: int = 100):
        def update(obj):
            print(obj)
        ani = FuncAnimation(self.fig, update, frames=list(itertools.chain.from_iterable([obj.get_orientations() for obj in self.pieces])), interval=interval)

#        def update(obj):
#            obj.plot(ax=self.ax, color='red')
#            if len(self.ax.collections) > 2:
#                print(self.current_piece_index)
#                self.ax.collections[2-self.current_piece_index].remove()